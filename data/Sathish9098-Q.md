# LOW FINDINGS 

##

## [L-1] Salt predictability in `CREATE2 opcode can be exploited 

### Impact 
This is because the salt is generated by hashing the last 32 bytes of the creation code. This means that if the creation code is known, the salt can be predicted

### POC

```solidity
FILE: ERC725/implementations/contracts/ERC725XCore.sol

261: bytes32 salt = BytesLib.toBytes32(creationCode, creationCode.length - 32);

```
https://github.com/ERC725Alliance/ERC725/blob/7171a0e25e83cfe4c4dec6262bb62b4422c0478f/implementations/contracts/ERC725XCore.sol#L261

### Recommended Mitigation
One way is to use a random salt. This will make it more difficult for an attacker to predict the salt

##

## [L-2] Use safeTransfer/safeTransferFrom functions 

## Check transfer functions return values 

## transfer function status must be checked 

## Lack of pricision

## Avoid devide by zero 







# NON CRITICAL

##

## [NC-1] Shorter inheritance list

https://github.com/code-423n4/2023-06-lukso/blob/9dbc96410b3052fc0fd9d423249d1fa42958cae8/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol#L96-L104

##

## [NC-2] Use keccak256() instead of BytesLib.toBytes32()

https://github.com/ERC725Alliance/ERC725/blob/7171a0e25e83cfe4c4dec6262bb62b4422c0478f/implementations/contracts/ERC725XCore.sol#L261







